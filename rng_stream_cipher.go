package crypka

import (
	"crypto/cipher"
)

// RNG, which uses some stream encryption algorithm in order to generate random data from small seed.
// It automatically reseeds RNG when it's about to reach it's max generated bytes.
type EncStreamRNGAlgo struct {
	CipherFactory           func(key []byte) (res cipher.Stream, err error)
	KeyLength               int
	ResedKeyLength          int // if zero, then no reseeding will happen
	CipherMaxGeneratedBytes uint64

	// NIY FOR NOW, see TODO below
	// TotalMaxGeneratedBytes  uint64 // allows user forcibly seting MaxGeneratedBytes, if lower than MaxGeneratedBytes then no reseeding will happen
}

func (algo *EncStreamRNGAlgo) GetInfo() RNGAlgoInfo {
	var maxGeneratedBytes uint64
	if algo.ResedKeyLength == 0 {
		maxGeneratedBytes = algo.CipherMaxGeneratedBytes
	}

	return RNGAlgoInfo{
		BaseAlgorithmInfo: BaseAlgorithmInfo{
			Type:     RNGAlgorithmType,
			IsSecure: true,
		},
		RNGType:           SeedRNGType,
		MinSeedLength:     algo.KeyLength,
		MaxSeedLength:     algo.KeyLength,
		MaxGeneratedBytes: maxGeneratedBytes,
	}
}

func (algo *EncStreamRNGAlgo) MakeRng(ctx RNGGenerationContext, seed []byte) (rng RNG, err error) {
	if len(seed) != algo.KeyLength {
		err = ErrInvalidRNGSeed
		return
	}

	cipher, err := algo.CipherFactory(seed)
	if err != nil {
		return
	}

	/*
		keyLength := algo.ResedKeyLength
		if keyLength == 0 {
			keyLength = algo.KeyLength
		}
	*/

	rng = &cipherRNG{
		cipher:                  cipher,
		maxCipherGeneratedBytes: algo.CipherMaxGeneratedBytes,
		// maxTotalGeneratedBytes:  algo.TotalMaxGeneratedBytes,

		reseedKeyLength: algo.ResedKeyLength,
		cipherFactory:   algo.CipherFactory,
	}
	return
}

type cipherRNG struct {
	maxCipherGeneratedBytes uint64
	cipherGeneratedBytes    uint64

	// TODO(teawithsand): implement limit of total amount of bytes generated
	// totalGeneratedBytes    uint64
	// maxTotalGeneratedBytes uint64

	reseedKeyLength int
	cipher          cipher.Stream
	cipherFactory   func(key []byte) (res cipher.Stream, err error)

	cachedError error
}

func (rng *cipherRNG) Read(buf []byte) (sz int, err error) {
	for {
		if rng.cachedError != nil {
			err = rng.cachedError
			return
		}

		reqBytes := uint64(len(buf))

		readBytesRaw := reqBytes

		if rng.maxCipherGeneratedBytes > 0 {
			// FIXME(teawithsand): this may overflow(at least in theory), which would result in invalid behaviour
			if rng.cipherGeneratedBytes+reqBytes+uint64(rng.reseedKeyLength) > rng.maxCipherGeneratedBytes {
				readBytesRaw = rng.maxCipherGeneratedBytes - rng.cipherGeneratedBytes - uint64(rng.reseedKeyLength)
			}
		}

		readSize := int(readBytesRaw)

		// 1. Read as much data as possible
		readBuf := buf[:readSize]
		buf = buf[readSize:]

		if len(readBuf) > 0 {
			for i := range readBuf {
				readBuf[i] = 0
			}

			rng.cipher.XORKeyStream(readBuf, readBuf)
			sz += len(readBuf)
			rng.cipherGeneratedBytes += uint64(len(readBuf))
		}

		// 2. If there is some buf left, then reseed
		if len(buf) > 0 {
			if rng.reseedKeyLength == 0 {
				rng.cachedError = ErrRNGOutOfEntropy
				if sz == 0 {
					err = ErrRNGOutOfEntropy
				}
				return
			}

			var newCipher cipher.Stream

			seed := make([]byte, rng.reseedKeyLength)
			rng.cipher.XORKeyStream(seed, seed)
			rng.cipherGeneratedBytes += uint64(rng.reseedKeyLength)

			if rng.cipherGeneratedBytes > rng.maxCipherGeneratedBytes {
				panic("crypka: assertion filed")
			}

			newCipher, err = rng.cipherFactory(seed)
			if err != nil {
				rng.cachedError = err
				if sz > 0 {
					err = nil
				}
				return
			}

			rng.cipherGeneratedBytes = 0
			rng.cipher = newCipher
		} else {
			// otherwise exit
			return
		}
	}
}
